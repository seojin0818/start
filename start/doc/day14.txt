# day14

참고 ]

	오버라이드 규칙
		
		1. 함수의 원형 유지
		2. 접근지정자는 같거나 넓은 방향으로
		3. 예외처리는 같거나 좁은 방향으로
			예외를 전이하는 함수는
			throws 하는 예외는 같거나 줄어들 수 있음 (개수)
			하지만 상위 클래스에서 던지지 않은 예외를 던지면 안됨
			
			ex ]
			
				void add(int a, int b) throws InvalidNumberException, NotANumberException {}
				
				이것을 오버라이드 해서
				
				void add(int a, int b) throws InvalidNumberException, NotANumberException {}	==>		O	: 예외를 똑같이 써도 O
				
				void add(int a, int b) throws InvalidNumberException {}			==================>		O	: 예외의 갯수가 줄어드는건 O
				
				void add(int a, int b) throws Exception {}	======================================>		X 	: 예외의 범위가 넓어지면 X
				
				void add(int a, int b) throws NumberException {} =================================>		X	: 상위 클래스의 함수에서 던지지 않은 예외는 X

-------------------------------------------------------------------

Object 클래스
==> 자바로 만든 클래스의 최상위 클래스 역할을 하는 클래스
	특별히 하는 일은 별로 없고 자바에서 상속 관계를 명확하게 하기 위한 역할을 주로 함
	
	1. equals()
	==> 비교함수
		Object 클래스가 가지는 이 함수는
		내용을 비교하는 기능이 아니고
		주소를 비교하는 기능의 함수
		
	참고 ]
		
		우리가 만드는 클래스를 사용하는 방법
		
			1. 객체를 만들어야 함
				==> Heap 영역에 내용을 올려놔야함
				
				클래스 이름  변수 = new 클래스 이름();
				
			2. 변수(주소)를 이용해서 내부의 멤버들을 사용함
			
	참고 ]
		
		우리가 String 클래스의 equals() 를 내용을 비교하는 함수로 알고 있는데
		이것은 String 클래스가 Object 클래스가 물려준 equals() 를 오버라이드해서
		내용을 비교하는 기능으로 바꾼것을 사용하는 것
		
	참고 ]
	
		우리가 만드는 클래스도 내용 비교를 하도록 원한다면
		이 함수를 오버라이드해서 기능을 수정하면 될 것
		
-------------------------------------------------------------------

	2. toString()
	==> 자바는 주소를 내부적으로 사용하고 있음
		하지만 주소를 개발자에게 노출하지는 않음
		
		대신 주소(변수가 기억하고 있는 것)를 출력하면
			"클래스 이름@해쉬코드값" 의 형태로 출력하게 됨
			
			참고 ]
			
				해쉬코드값
				==> 자바는 주소를 내부적으로 해쉬테이블을 이용해서 관리함
					해쉬코드값은 그 주소를 관리하는 해쉬테이블의 코드값이 됨
			
			문제는 주소를 출력하려고 하면 내용이 출력되는것이 아니고 해쉬코드 형태의 코드값이 출력된다는 것
			이것은 이런 형태의 문자열을 만들어서 반환해주는 기능의 함수가 자동 호출되어서 출력되는 것
			이 때 자동 호출되는 함수가 toString()
			
			만약 우리가 만든 클래스에서 주소(변수)를 출력할 때
			해쉬코드값이 아닌 우리가 원하는 데이터로 출력되게 하려면
			이 toString() 를 오버라이드해서 원하는 형태로 문자열을 반환해주도록 만들어주면 됨
			
-------------------------------------------------------------------

	3. clone()
	==> 자기자신을 깊은 복사해주는 함수
	
		이 함수는 protected 함수이므로 
		상속 받은 클래스나
		같은 패키지 내에 있는 클래스에서만 사용 가능
	
	4. hashCode()
	==> 해쉬테이블에 주소를 관리하는 코드값을 알려주는 함수
	
-------------------------------------------------------------------

	String 클래스
	==> 문자열을 관리하는 클래스
	
		*****
		주의사항 ]
			
			String 클래스의 가장 큰 단점
			==> String 클래스는 내용이 변경되면
				변경된 내용을 다시 메모리에 저장하고
				주소를 바꿔치기 함
				
			따라서 String 내용 변화가 심하면 메모리의 소모가 증가하게 됨
			
	결론적으로 변화가 심한 문자열은 String 클래스를 사용하면 불리함
	이럴때 사용할 수 있는 클래스가
	
		StringBuffer
		StringBuilder
		
	가 제공되고 있음
	
	참고 ]
	
		그래도 간단한 문자열 처리는 자주 사용하는 클래스이므로
		클래스 중 유일하게 new 시키지 않고 사용할 수 있도록 준비해놓은 클래스
		
		ex ]
		
			String str = new String("홍길동");
			String name = "홍길동";
			
	참고 ]
	
		String 클래스는 유일하게 함수를 사용하지 않고
		연산자(+) 를 사용해서 결합연산 처리 가능
		
	결론 ]
		
		변화가 심한 문자열 데이터는 String 타입으로 작업하기보다는
		StringBuffer 를 사용해서 작업하는 것이 유리함
		
	참고 ]
	
		String 소속의 함수는 자신이 기억한 데이터 자체를 변경할 수 있는 함수는 존재하지 않음
		다만 연산된 결과를 반환해주는 형태의 함수들만 존재함
		
-------------------------------------------------------------------

StringBuffer
==> String과 동일하게 문자열을 관리하는 클래스
	
	*****
	차이점 ]
	
		String 은 내용의 변화가 일어나면 새로운 메모리의 공간을 확보해서 사용하는데
		StringBuffer의 경우는 String의 이런 단점을 보완하고자 만들어놓은 클래스
		내용의 변화가 생기면 현재 메모리에 변화된 내용을 그대로 기억함
		
	사용법 ]
	
		1. 객체를 만들기
		StringBuffer buff = new StringBuffer([문자열])
		
		2. 만들어진 객체에 문자열을 결합시키기
		buff.append(문자열);
		
		3. 문자열 데이터가 필요한 순간에 문자열로 변환시키기
		String str = buff.toString();
		
-------------------------------------------------------------------

StringTokenizer
==> 문자열을 특정 구분자를 기준으로 자르는 작업을 할 때 사용하는 클래스

	주의 ]
	
		분리된 결과물은 배열과 같은 형태로 버퍼메모리에 기억됨
		이 때 기억된 내용을 접근해서 사용하게 되면 그 내용은 메모리에서 사라짐
		
	사용방법 ]
		
		StringTokenizer token = new StringTokenizer(문자열, 구분문자);
		
		while(token.hasMoreElement()){
			// 하나씩 꺼내서 작업
			
			Object o = token.nextElement();
			String str = token.nextToken();
		}
		
-------------------------------------------------------------------

Math 클래스
==> 주로 수학적인 기능을 처리하는 함수로 구성된 클래스
	멤버들이 모두 static 멤버이므로 굳이 new 시키지 않아도 사용할 수 있는 클래스
	아예 new 시키지 못하도록 해놓은 클래스
	
-------------------------------------------------------------------

래퍼 클래스(Wrapper Class)
==> 주소를 사용하는 (클래스 타입의 데이터를 사용하는) 곳에서 Value Type (기본 데이터타입) 을 사용할 수 없는 문제가 생길 수 있음
	이런 문제를 해결하기 위해서 만든 클래스를 래퍼 클래스라고 함
	즉, 기본 데이터타입을 객체의 형태로 사용할 수 있도록 만든 클래스
	
	참고 ]
	
		자바는 Object 클래스를 중심으로 계층 구조화해서
		클래스를 이용하도록 만든 객체지향 언어
		
		Object o = 100; 이 안될 수 있음 100 은 그냥 기본데이터타입이고 멤버도 없고 함수도 없으니까 처리할때 문제 발생
		
		하지만 Value Type(기본 데이터타입 : boolean, char, byte, short, int, long, float, double) 만큼은
		객체지향원리를 사용하지 않음
		따라서 다형성 구현에 있어서 문제 발생
		
		ex ]
		
			void abc(Object o){
			
			}
			==> 이 경우 이 함수는 모든 데이터를 처리할 수 있는 기능으로 만들었음에도 불구하고
				기본 데이터타입의 데이터는 이 함수로 처리할 수 없는 문제가 발생
				
		참고 ]
			
			Boxing 과 Unboxing
			
				Boxing : 기본 데이터타입을 참조형 타입으로 변환하는 것
				Unboxing : 참조형 타입의 데이터를 기본형으로 변환하는 것
							Heap 영역에 있는 데이터를 다시 Stack 으로 꺼내는 것
							
		결론적으로
		래퍼 클래스란 Boxing과 Unboxing을 해주기 위한 클래스
		
		참고 ]
			
			자바 버전 1.4 이후부터는 Boxing과 Unboxing이 자동으로 처리됨
			
			ex ]
			
				Integer no1 = 10;	// 자동 Boxing
				
				int num = no1;		// 자동 Unboxing
		
-------------------------------------------------------------------

java.util 패키지 소속의 유용한 클래스

1. Objects
==> 이 클래스는 100% static 함수로만 구성된 클래스
	클래스(객체)를 다룰 때 유용한 몇 가지 유틸리티적인 함수로 구성된 클래스
	
	ex ]
	
		isNull(Object obj)
		==> 객체의 내용이 있는지를 확인하는 함수
			new 시킨 결과가 있는지를 확인하는 함수
	
	참고 ]
	
		null
		==> 참조형 변수에 주소가 없는 상태를 말하는 것
			이것은 찾아갈 대상이 없다는 말
			이 말은 이것은 아직 사용할 준비가 되지 않았다는 것
			
							