# day15

Random 클래스
==> 난수를 발생하는 클래스
	우리가 알고있는 Math.random() 보다는
	좀 더 다양한 형태의 난수를 발생할 수 있는 장점
	
	참고 ]
		
		seed
		==> 컴퓨터에 난수 발생은 그 순간 실제로 난수를 만들어주는 것이 아니고
			이미 컴퓨터 내부에는 난수 테이블이 존재하고 있음
			그리고 이 난수 테이블에서 순서대로 꺼내서 주는 역할
			seed란 난수 테이블에서 난수를 꺼내는 위치를 말하는 용어
			
-------------------------------------------------------------

BigDecimal 클래스
==> 정수를 표현할 수 없는 숫자를 사용하기 위한 클래스

	주로 데이터베이스와 연동할 때
	
	데이터베이스의 숫자 타입은
	오라클의 경우 NUMBER(숫자)는 최대 32자리까지 사용 가능
	이런 형태의 데이터는 자바에서는 처리할 수 없으므로
	이런 유형의 데이터를 처리하기 위해서 만들어진 클래스
	
	예 ]
	
		BigDecimal big = new BigDecimal("12345678901234567890123456789012");
		
--------------------------------------------------------------

정규식(정규표현식) 검사
==> 주어진 문자열이 특정한 규칙에 맞도록 만들어져 있는지를 확인하는 기능

	예 ]
		
		주민번호가 6-7 자리로 구성되어있는지
		아이디가 순수하게 숫자와 문자로만 구성되어 있는지
		아이디가 최소 몇글자 이상으로 만들어져 있는지
		
	사용하는 클래스
		java.util.regex.Pattern
		==> 정규식 검사에 사용할 정규식 문법을 지정할 클래스
		
		java.util.regex.Matcher
		==> 정규식 검사를 실제로 실행할 클래스
		
	참고 ]
	
		정규표현식 문법
		
			1. c[a-z]*
				==> 문자를 기록하면 반드시 그 위치에 기록한 문자가 와야함
					[] 안에 기록하면 그 중 하나가 와야함
					*는 바로 앞에서 지정한 글자가 0개 이상 올 수 있음
				
				==> c로 시작하고 그 후에는 알파벳 소문자가 0개 이상 오면 됨
				
			2. c[a-z]
				==> c로 시작하고 그 다음 글자는 알파벳 소문자가 한 글자 와야함
				
			3. c[a-zA-Z]
				==> c로 시작하고 그 다음 글자는 알파벳이 오면 됨
				
			4. c[a-zA-Z0-9]
				==> c로 시작하고 그 다음 글자는 알파벳 또는 숫자가 한 글자 와야함
				
			5. .*
				==> .은 모든 문자(알파벳, 한글까지 포함)를 의미
				
				==> 어떤 문자라도 0개 이상 오면 됨
				
			6. C.
				==> 첫 글자는 C로 시작하고 그 다음 문자는 어떤 문자라도 한글자만 오면 됨
				
			7. C.*
				==> 첫 글자는 C로 시작하고 그 다음 문자는 어떤 문자라도 0개 이상 오면 됨
			
			8. c\.
				==> \.은 반드시 그 위치에 .이 와야함
				==> c.이어야 함
				
			9. c\d
				==> \d는 숫자를 의미
				==> 첫 글자는 소문자 c로 시작하고 그 다음 문자는 숫자가 와야함
				==> c[0-9]와 동일한 의미
			
			10. c.*t
				==> 첫 글자는 c로 시작하고 마지막 글자는 t가 와야함
					중간에 어떤 문자라도 0개 이상 올 수 있음 / 예 ] cjdsapf9ds0-at
			
			11. [b|c].*
				==> b 또는 c로 시작하고 그 이후에는 어떤 문자라도 0개 이상 올 수 있음
				==> [b|c] == [bc]
						  == [b-c]
			
			12. [^b|c]
				==> ^ 의 의미는 Not의 의미
				== b 또는 c 이외의 문자 한개
				
			13. .*a.*
				==> a 문자가 포함된 모든 문자열
				
			14. .*a.+
				==> * : 0글자 이상
					+ : 1글자 이상
				==> a가 들어가는데 a가 끝문자는 아닌 문자열
				
			15. [b|c].{2}
				==> {숫자} : 글자수를 의미
					{숫자,} : 숫자 개 이상의 의미
					{숫자1, 숫자2} : 숫자 1개 이상 숫자 2개 이하
				
				==> b 또는 c로 시작하고 어떤 문자라도 그 이후에 두 글자가 와야함

			16. .{2,3}
				==> 어떤 문자라도 2글자 이상 3글자 이하가 와야함
				
		예 ]
		
			핸드폰 번호 표현식 ]
				
				01[0-9]-[0-9]{4}-[0-9]{4}
				
			전화번호 표현식 ]
				
				0[0-9]{2,3}-[0-9]{3,4}-[0-9]{4}
				
--------------------------------------------------------------
*****
컬렉션(Collection)
==> 많은 양의 데이터를 손쉽게 보관할 수 있는 클래스들의 집합

	배열을 이용해도 많은 양의 데이터를 보관할 수 있지만
	배열의 단점
				크기 변경 불가
				==> 한 번 데이터의 양을 결정하면 그 양보다 많은 데이터는 보관할 수 없음
				데이터의 입출력에 많은 제약을 가짐
				==> 반드시 위치를 알아야 데이터 입출력 가능
			
	종류 ] *** 암기
	
		1. List 계열
			특징
				1) 입력 순서 보장 (처리속도 느림)
				2) 중복데이터도 다시 저장 가능
		
		2. Set 계열
			특징
				1) 입력 순서 보장 못함
					(클래스 자체에서 나름의 규칙에 의해서 데이터를 정렬해 보관)
						따라서 처리속도 빠름
				2) 중복 데이터 허용하지 않음
					==> 중복된 데이터가 입력 되어도 먼저 입력된 데이터를 기억함
						같은 데이터는 한번만 저장함
		
		3. Map 계열
			특징
				1) 데이터를 그 데이터를 구분하는 키값과 한쌍을 만들어서 저장함
				2) 입력 순서 보장 못함
				3) 먼저 입력된 데이터보다 나중에 입력된 데이터를 기억함
					==> 데이터는 중복되어도 상관없지만
						키값은 중복해서 사용하면 안됨
						
		참고 ]
			
			List 계열과 Set 계열은 같은 상위 클래스를 가짐
			Map 계열은 상위 클래스가 다름
			List와 Set은 다형성 처리 가능 (서로 변환 가능)
			Map은 독립적으로 변환 불가능
			
--------------------------------------------------------------

List 계열

	1. Vector
		==> 내부적으로는 배열형태를 만들어서 데이터를 보관하는 컬렉션의 일종
		
			장점
				입력속도와 검색속도 빠름
			단점
				중간에 데이터를 삽입하거나, 데이터를 삭제하는 속도는 느림
			결론
				데이터의 변화가 거의 없는 프로그램에서 많이 사용됨
				
		생성방법
			
			1) Vector()
				==> 배열의 크기를 10으로 정한 상태로 벡터를 만들어줌
					이 때 데이터가 많으면 크기는 변경됨 / (* 2만큼 확장)
					
			2) Vector(Collection c)
				==> 다른 컬렉션의 데이터를 복사해서 벡터를 만들어줌
				
			3) Vector(int initialCapacity)
				==> 사용자가 직접 배열의 크기를 정하면서 벡터를 만듦
				
			4) Vector(int initialCapacity, int capacityIncrement)
				==> 3)번 + 데이터양이 증가할 때 추가할 배열의 크기를 정함
				
			참고 ]
			
				컬렉션은 데이터의 양에 관계없이 항상 데이터를 입력받을 수 있음
				이 때 데이터를 입력받을 공간을 확보해야 하는데
				규칙
					현재 공간 * 2 가 됨
					
			주요함수
				
				1. 데이터를 입력하는 함수
					add(Object obj) // 자바에서 쓰는 모든 데이터 타입 입력 가능하다는 의미
					add(int index, Object element) // 인덱스 정해서 거기다 추가할 수 있다는 의미
					addAll(Collection c) // 다른 컬렉션에 있는 데이터를 모두 vector에 넣을 수 있다는 의미
					addAll(int index, Collection c) // 위치 정해서 모든 데이터 추가 가능하다는 의미
					addElement(Object obj)
					insertElementAt(Object obj, int index)
					
				2. 데이터를 수정하는 함수
					set(int index, Object element)
					setElementAt(Object obj, int idex)
					
				3. 데이터를 꺼내는 함수
					get(int index)
					elementAt(int index)
					firstElement()
					lastElement()
					elements()
					
				
				참고 ]
				
					E, V, K라고 표현한 것은 Object를 의미하는 제너릭스 용어
					
--------------------------------------------------------------

	2. ArrayList
	==> Vector의 신버전으로
		역시 배열 형태로 데이터를 관리하기 때문에
		Vector의 특징을 그대로 가지게 됨
		하지만 스레드에서 동기화 처리를 자동으로 해주므로
		요새는 Vector보다 ArrrayList를 선호하는 경향
		
		사용방법 역시 Vector와 유사함
		
		참고 ]
			
			List 계열의 주소(변수)를 출력하면
			마치 데이터가 나온 것처럼 보이지만
			이것은 toString()를 오버라이드 해놔서 반환된 문자열을 출력만 해주는 것
			따라서 절대로 데이터를 사용하는 개념은 아님
		
	3. LinkedList
	==> 내부적으로 이중 연결 리스트 방식으로 데이터를 보관하는 방식의 컬렉션의 일종
	
		장점 ]
			데이터를 중간에 끼워넣는 작업, 삭제 작업은 속도 빠름
		단점 ]
			데이터를 누적시키는 작업은 속도 느림
			
		주로 데이터의 변화가 심한 경우 많이 사용하는 컬렉션
		
	참고 클래스 ]
	
		Iterator
		==> 컬렉션은 많은 클래스의 집합이고 그 형태도 다름
			하지만 이들은 서로 혼용될 수 있음
			그런데 그 안에 데이터를 꺼내는 방식은 약간씩 다름
			List에서 데이터를 꺼내는 방식과 Set에서 데이터를 꺼내는 방식이 다름
			(꺼내는 소스를 다르게 만들어야함)
			
			그래서 데이터를 꺼내기 위해서만 사용하는 클래스를 따로 만들어놓음
			그 클래스가 Iterator 클래스
			즉, List 계열이든 Set 계열이든 Iterator로 변환만 시키면 한가지 방식으로
			데이터를 꺼낼 수 있게 됨
			
			특징 ]
				
				어제 배운 StringTokenizer처럼
				순차적으로만 꺼낼 수 있고
				한번 꺼낸 데이터는 자동 삭제
				
			참고 ]
				
				Collections 클래스
				==> 이 클래스는 이름은 컬렉션이지만 컬렉션의 기능은 없고
					컬렉션을 이용할 때 필요한 부가적인 기능들을 제공하는 유틸리티적인 클래스
					
					주의 ] 
					
						매개변수에서 List를 요구하면 List 계열을 주면 되고
						Set을 요구하면 Set 계열을 주면 됨
						Collection을 달라고 하면 List, Set 중 하나를 주면 됨
						Map을 요구하면 Map 계열을 주면 됨
						
				참고 ]
					
					일반적인 sort는 오름차순 정렬
					만약 정렬 방식을 변경하고자 한다면
					sort(List list, Comparator c)을 사용해야 함
					
--------------------------------------------------------------

Set 계열
==> 입력한 순서대로 보관하고 있을 보장 없음
	(==> 자기 나름의 규칙을 가지고 내부적으로 정렬해서 보관)
	중복된 데이터는 한번만 저장함
	(==> 같은 데이터가 입력되면 먼저 데이터를 지우고 새로운 데이터로 입력함)
	
	1. HashSet
		==> HashCode를 이용해서 정렬해서 보관하는 방식의 컬렉션
			따라서 우리가 생각하는 정렬이 이뤄지지 않음
			
		참고 ]
		
			Set 계열의 컬렉션은 꺼내는 기능의 함수가 존재하지 않음
			==> 왜?
				개발자가 데이터가 저장된 장소를 모르기 때문에
				특정 위치를 지정하면서 데이터를 꺼낼 수 없음 (index라는 것이 없음)
				따라서 Iterator로 변환해서 순서대로 꺼내서 사용하도록 하고 있음
				또는 List 계열로 변환해서 인덱스를 사용해서 꺼낼 수도 있음
				
	2. TreeSet
		==> 내부적으로 Tree Sort라는 알고리즘을 이용해서 데이터를 보관하는 기능을 가진 컬렉션의 일종
		
		특징 ]
			
			우리가 생각하는 정렬 방식을 그대로 사용
			
		생성방법 ]
		
			TreeSet(Comparator comparator)
			==> 정렬 방식을 변경해서 TreeSet 만들기
			
			TreeSet(SortedSet<E> s)
			==> TreeSet을 이용해서 다시 TreeSet 만들기
			
		참고 함수 ]
		
			subSet()
			==> 하나의 Set에 담긴 내용 중에서 특정 부분만 골라서 새로운 Set을 만드는 함수
			
			headSet(E toElement)
			==> 처음부터 지정한 부분까지 골라서 새로운 Set을 만듦
			
			tailSet(E fromElement)		
			==> 지정한 부분에서부터 마지막까지 골라서 새로운 Set을 만듦
