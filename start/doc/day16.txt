# day16

Map
==> 하나의 데이터를 그 데이터를 구분할 수 있는 키값과 한쌍으로 만들어서
	데이터를 기억하는 컬렉션의 일종
	그리고 사용할 경우에는 키값을 이용해서 데이터를 꺼낼 수 있도록 하는 것
	ArrayList에서는 인덱스로 꺼냈고 Map 계열은 키값으로 꺼냄
	
	Map 계열은 많은 양의 데이터를 보관하는 용도보다는
	데이터를 손쉽게 구분하여 사용할 목적
	
HashMap / HashTable

	HashTable : 구버전에서 나온 클래스
	HashMap : 신버전
	
	따라서 HashMap 사용 권장
	
	내부적으로 키값을 해쉬 테이블을 이용해서 정렬해서 보관
	
	주요함수
		
		put(Object key, Object value)
		==> 데이터를 입력하는 함수
		
		get(Object key)
		==> 데이터를 꺼내는 함수
		
		values()
		==> 데이터들만 꺼내주는 함수
		
		keys()
		==> 키값들만 꺼내주는 함수
		
		참고 ]
		
			keys()로 꺼낸 데이터는 Enumeration로 반환
			==> 이 클래스는 Iterator의 구버전
			즉, 데이터를 순차적으로 꺼낼 수 있는 것
			
		참고 ]
		
			HashMap에서는 키값만 꺼내는 함수가 keySet()으로 변경되었음
			
		참고 ]
		
			entrySet()
			==> Map은 반드시 키값을 알아야 꺼낼 수 있음
				(위의 함수를 이용하면 다른 방식으로 꺼낼 수 있지만)
				==> 키값과 데이터를 Set으로 묶어주는 함수
				
			문제는
				Map은 항상 두개(키값과 데이터)가 있어야 저장됨
				Set은 오직 한개만 저장됨
				어떡하든지 Key와 데이터를 하나로 묶어야만 Set에 저장
				
				==> 이 문제를 해결하기 위한 클래스(VO 클래스) Value Object 데이터 전달용으로 사용하는 클래스
					그 클래스가 바로
						Map.Entry
				==> 이 클래스 안에는 Key와 Value 변수가 은닉화 되어있고
					이 변수를 사용할 수 있도록 함수 제공
					이렇게 두개의 변수를 하나로 묶어놓은 클래스
					
---------------------------------------------------------

TreeMap
==> TreeSet과 마찬가지로 내부에서 정렬하면서 데이터를 기억하는 Map
	이 때 정렬기준으로 키값을 이용해서 정렬
	따라서 키값이 정렬이 되지 않는 클래스를 사용할 수 없고
	필요하다면 정렬방식을 정해서 사용해야 함
	
	참고 ]
	
		가끔 클래스를 보면 기능을 필요로 해서 만들어진 것이 아니고
		여러개의 데이터를 하나로 묶기 위한 목적으로 만들어놓은 클래스가 있음
		
		class Tmp {
			String name;
			int age;
		}
		
		이런 클래스를 우리는 데이터 빈 클래스라고도 하고
		Value Object(VO)라고도 함
		또는 이런 클래스들은 데이터를 전달할 목적으로 사용되므로
		DTO(Data Transfer Object)라고도 함
		
	참고 ]
	
		컬렉션 안에는 다시 컬렉션을 입력할 수 있음
		왜?
			컬렉션 안에는 모든 클래스를 입력할 수 있으므로
			컬렉션도 클래스이므로 저장 가능
			
---------------------------------------------------------

Properties
==> Map의 역할을 하는 클래스

	일반 Map과의 차이점은 파일(외부장치)을 이용해서 직접 데이터를 읽어서
	Map처럼 저장할 수 있고
	Map에 저장된 데이터를 직접 파일(외부장치)로 출력해서 저장할 수 있음
	
	주의 ]
	
		파일의 내용을 읽을 때 인코딩이 되지 않는다는 사실
		==> 한글 파일의 경우 파일 자체에서 인코딩하지 않으면
			내용이 한글인 경우 한글이 깨져서 들어옴
			
	참고 ]
		
		한글이 포함된 파일을 Properties에서 사용하기 위해서 인코딩 하는 방법
			1. cmd창 열기
			2. Path에 JAVA_HOME이 등록되어 있는지 확인하기
			3. native2ascii 명령을 사용해서 인코딩하기
			
				형식 ]
					
					native2ascii	현재 파일	새로운 파일
					
				예 ]
					
					native2ascii	d:\sample.txt	d:\sample_ko.txt
					
	참고 ]
	
		Properties 클래스는 오직 String으로만 키값과 데이터를 처리해야 함
		
	참고 ]
	
		Properties는 이외에도 또 하나의 특징을 가지고 있는데
		현재 프로그램의 정보를 Map으로 자동처리하는 기능이 있음

---------------------------------------------------------

제너릭스
==> 컬렉션은 모든 형태의 데이터를 다 입력 받을 수 있음
	하지만 실무에서는 한가지 형태로 입력 받는것을 원칙으로 함
	그런데 꺼낼때는 항상 강제 형변환 해줘야 함
	즉, 나는 한가지 형태로 결정해서 데이터를 입력해 놓았는데
	꺼낼때는 자동 형변환이 일어나지 않기 때문에
	항상 강제 형변환을 해줘야 함
	
	제너릭스란?
	==> 컬렉션에 입력되는 데이터를 미리 알려줌으로써
		나중에 꺼낼때 좀 더 편하게 (형변환 없이) 사용할 수 있도록 해주는 것
		
	형식 ]
		
		ArrayList<String> list = new ArrayList<String>();
		==> list에는 문자열만 입력 가능
		
	참고 ]
		
		제너릭스는 전파되지 않음
		하나의 컬렉션이 제너릭스 선언되었더라도
		그 컬렉션을 이용하는 다른 컬렉션은 제너릭스를 잊어버림
		결론적으로 새로운 컬렉션도 다시 제너릭스 선언 해줘야 함
		
	참고 ]
	
		특수한 제너릭스
		원래 제너릭스는 특정 클래스만 입력 받을 목적으로 사용
		
		형식 ]
		
			<? super 클래스이름>
			==> 지정한 클래스 포함 상위 클래스까지 허락
			
			<? extends 클래스이름>
			==> 지정한 클래스 포함 하위 클래스까지 허락
			
		이 방법은 제너릭스 선언을 하지 않은 것과 동일한 효과가 있음
		왜냐하면 형변환을 해줘야 하기 때문에

---------------------------------------------------------

어노테이션
==> 내부적으로 약속된 실행을 자동으로 처리하도록 하는 명령의 일종

	주로 화면에 실제 보이는 실행이 아니고
	점검을 한다든지 선언적인 실행(이 클래스는 어떻게 동작해라)의 의미를 가진 명령
	
	형식 ]
	
		@명령