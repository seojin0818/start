# day08

배열의 복사

	종류 ]
	
		1. 얕은 복사
		==> 주소만 복사하는 방법
			
			특징 ]
			
				데이터를 공유하기 때문에
				한 곳에서 수정하면 다른 곳에서도 수정된 내용 사용
				
			방법 ]
			
				int[] a = new int[5];
				....
				
				int[] b;
					이 변수는 배열의 주소를 기억할 변수를 만들어준 결과
					b 안에는 데이터는 기억할 수 없고
					오직 같은 Heap 타입의 int[] 의 주소만 기억할 수 있음
					
				b = a; ==> 얕은 복사가 됨
						   a에서 만든 배열을 같이 공유하게 됨
						   
			참고 ]
			
				얕은 복사
				==> 지역변수는 그 지역에서만 사용할 수 있으므로
					다른 지역에서 Heap 영역의 데이터를 사용할 목적으로 많이 사용되는 방법
		
		2. 깊은 복사
			==> 데이터를 복사하는 방법
			
				데이터가 복사되었다는 것은 
				Heap 영역에 다른 인스턴스(new 명령으로 생겨난 결과물)가 만들어졌다는 것이므로 
				변수가 기억하는 주소가 달라지게 됨
				☆★☆★
				복사된 데이터는 독립적으로 사용됨
				
			방법 ]
			
				명령을 사용해서 처리
				
				System.arraycopy(#1, #2, #3, #4, #5)
				
					#1	-	원본 배열의 주소
					#2	- 	원본 데이터의 복사를 시작할 위치 
					#3	-	복사 받을 배열의 주소
					#4	-	복사 받을 배열의 시작 위치값
					#5	-	복사 받을 데이터의 개수
					
------------------------------------------------------

배열의 단점

	1. 한 번 배열의 크기를 정하면 크기 조절 불가
	
		예 ]
		
			int[] no1 = new int[10];
			...
			// 작업을 하다가 10개를 추가해야 하는 경우
			int[] no2 = new int[20];
			
			// 데이터 복사
			System.arraycopy(no1, 0, no2, 0, 10);
			// 추가 데이터 입력
			no2[10] = ???;
			no2[11] = ???;
			
	2. 같은 형태의 데이터만 관리 가능
		==> 주소는 Heap Type에 의해서 결정이 되고
			Heap Type이 다르면 사용 불가
			
		예 ]
		
			int[] a = new int[10];
			
			float[] b;
			
			b = a; ==> 절대 불가
			
------------------------------------------------------

String 배열

	참고 ]
		
		String 역시 참조형 타입
		
		String str = "Hong";
		
		str에는 데이터 자체의 주소가 기억되고
		
		String str = new String("Hong"); 라고 변수를 만들면
		변수는 Heap에 만들어진 인스턴스의 주소를 기억하고
		인스턴스가 데이터의 주소를 기억
		
----------------------------------------------------------
	
	String 배열 만들기
	
		String[] str; // 배열변수 선언 - 데이터를 사용할 준비
		str = new String[5];
		==> 데이터 초기화가 되어있지 않은 상태
			아직 각 인덱스가 비어있는 상태 (데이터가 결정되지 않은 상태)
			
		str[0] = "Hong";
		str[1] = "Dooly";
		==> 위처럼 데이터 공간까지 만들어줘야함
		
		String 배열도 초기화 가능
		String[] names = {"흰색", "주황색", "보라색", "연두색", "파란색"};
		
----------------------------------------------------------

	참고 ]
		
		문자열도 필요에 따라서 char[] 형태로 변환해서 사용 가능
		
		방법 ]
		
			toCharArray();
			
		예 ]
		
			String name = "gomdol";
			
			char[] ch = name.toCharArray();
			
			ch[0] ==> g
			ch[1] ==> o

----------------------------------------------------------

	참고 ]
		
		String 클래스에서 자주 사용되는 함수
		
			1. charAt(위치값)
				==> 해당 위치의 문자를 알려줌
				
			2. length()
				==> 문자열의 길이를 알려줌
				
			3. substring()
				==> 문자열 중에서 원하는 문자열만 따로 뽑아서 반환
				
					형식 1 ]
						
						substring(시작위치);
						==> 시작위치에서부터 맨 마지막까지 모두 추출
						
					형식 2 ]
						
						substring(시작위치, 종료위치);
						==> 시작위치에서부터 종료위치 이전 문자까지 추출
						
						☆★☆★
						주의 ]
						
							시작위치는 0부터 카운트해서 지정
							종료위치는 1부터 카운트해서 지정
							
			4. equals()
				==> 문자열의 데이터 자체가 같은지 비교해서 논리값으로 반환
				
----------------------------------------------------------

2차원 배열
==> 1차원 배열을 관리하는 배열
==> 배열 안에 다시 배열이 들어있는 형태
	(정확히는 배열 안에 1차원 배열의 주소가 기억됨)
			
	2차원 배열을 만드는 방법 ]
	
		1. 배열 주소를 기억할 변수 만들기
			==> Heap 영역에 있는 데이터는 주소를 알아야 사용하기 때문
			
			방법 ]
			
				데이터타입[][]		변수이름;
				==> [] 가 1개이면 1차원 배열이 되고
						  2개이면 2차원 배열
						  3개이면 3차원 배열
						  ...
						  
			예 ]
			 	
			 	int[][] num; 정수 배열들을 관리하는 배열 num
			 	
			 	num = new int[5]; ==> X : new int는 1차원이고 변수는 2차원이라서 Heap type이 다름
			 							  
		2. 1차원 배열을 몇 개를 관리할지를 결정하고
		   1차원 배열의 주소를 기억할 메모리를 만듦
		   
		   방법 ]
		   
		   		new 데이터타입[개수][];
				==> 개수는 1차원 배열의 개수를 지정
				
			예 ]
				
				num = new int[5][];
				5개짜리 방만 만들어놓고 들어갈 데이터는 세팅되지 않음
				그것을 관리할 배열만 만들어진것
				
		
		3. 실제 정수를 관리하는 1차원 배열의 길이를 결정하고
			1차원 배열의 주소를 기억할 메모리 만들기
			
			방법 ]
				
				new 	데이터타입[개수];
				
			 예 ]
				
				num[0] = new int[3];
				
----------------------------------------------------------

	참고 ]
		
		2차원 배열도 사각형 형태의 배열을 만들 수 있음
		
		형식 ]
		
			데이터 타입[][]		변수 = new		데이터타입[행수][열수];
			
		예 ]
			
			int[][] num = new int[5][3];
			==> 정수 3개를 관리하는 배열 5개를 관리하는 배열
		
		주의 ]
			
			이해를 돕기 위해서 사각형으로 설명하지만
			실제로는 별도의 메모리 공간을 차지하는 배열이 만들어지고
			그 배열들을 관리하는 배열이 다시 만들어짐
			
		참고 ]
		
			2차원 배열도 초기화 가능
			
			방법 ]
				
				int[] num = {데이터1, 데이터 2, ...}; // 데이터 개수만큼 만들어지고 입력된 데이터로 초기화
				
				int[][] num = {{1,2}, {3, 4, 5}, {6, 7, 8, 9}};
				==> 여기서도 배열의 개수를 지정할 수는 없음
				
----------------------------------------------------------
			