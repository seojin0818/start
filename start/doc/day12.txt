# day12

상속
	==> 이미 만들어져있는 클래스를 다시 코딩하지 않고
		그대로 물려받아서 추가할 기능은 추가하고
		수정할 기능을 수정해서
		클래스를 제작해서 프로그램을 만들어나가는 기법
		
		참조형 변수 ]
			
			타입을 결정하는 것은
			인스턴스에 변수 쪽 클래스의 멤버가 모두 있느냐 모자라느냐
			
		결국
		상속 받은 클래스의 멤버는 상속해준 클래스의 멤버의 개수보다 많을 것
		
		오버라이딩(함수의 재정의)
			0.
			1. 함수의 원형이 일치해야함
				함수의 원형 : 반환값타입 + 함수이름 + 매개변수리스트
			2. 접근지정자는 같거나 넓은 방향으로
				참고 ] 클래스에 사용할 수 있는 접근지정자 : 생략, public
			3. 예외처리는 같거나 좁은 방향으로
			
		상속관계에 있는 경우
		상위 클래스의 변수에서 함수를 호출하게 되면
		최종적으로 하위 클래스에서 오버라이딩한 함수가 호출됨
			
---------------------------------------------------------

******
다형성
==> 하나의 변수를 이용해서 여러 형태의 클래스를 사용하도록 하는 방법

	Casting(주소의 형변환)
	==> 원칙적으로 주소는 다른 형태로 형변환 불가능
		즉, 주소는 Heap Type 형태에 따라 주소가 결정됨
		Heap 형태가 다르면 주소를 기억할 수 없음
		
		ex ]
		
			int[] num = new float[10]; ==> X
			Test t = new Sample(); // 상속 관계가 아닌 경우는 불가능
			
	***
	딱 한가지 경우에 한해서 주소(참조형 타입)의 형변환 가능
	상속 관계에 있는 클래스끼리는 형변환 가능
	왜 ? is a 관계이기 때문
	
		자동 형변환
			==> 하위 클래스의 주소가 상위 클래스 변수에 기억되는 것은
				자동적으로 형변환을 해줌
				
		강제 형변환
			==> 상위 클래스의 주소가 하위 클래스 변수에 기억되는 것은
				원칙적으로는 불가능
				다만 강제로 형변환을 해줘야함
				
			ex ]
			
				class Father {
				
				}
				
				class Son {
				
				}
				
				Father f = new Son(); // ==> 자동 형변환
				Son s = new Father(); // ==> X
				
				Father f1 = new Father();
				Son s = (Son) f1; ==> 강제 형변환
				
		다형성이란?
		
			상위 클래스의 변수를 이용해서 하위 클래스의 인스턴스를 이용할 수 있으며
			이것은 상위 클래스의 변수를 이용하면
			여러 하위 클래스의 인스턴스들을 다룰 수 있음
			
			하위 클래스의 인스턴스는 상위 클래스들의 레퍼런스로 사용 가능
			하위 클래스가 멤버가 더 많음
			
			참고 ]
				
				클래스의 인스턴스의 타입을 따질 때는
				반드시 그 인스턴스에 해당 클래스의 멤버가 존재하는지를 따져주면 됨
			
			참고 ]
			
				다형성을 개발자 입장에서 사용하는 방법
				
					1. 어떤 함수가 상위 클래스를 매개변수로 가지고 있으면
						하위 클래스의 인스턴스를 입력해도 상관 없음
						
						따라서 만약 어떤 함수가 Object 타입으로 매개변수가 정의되어있으면
						이 경우 Object 클래스의 인스턴스를 만들어서
						함수를 호출하는 경우는 없음
						대신 이 함수는 모든 클래스들의 인스턴스를 매개변수로 입력해도 되는 함수
					
					2. 어떤 함수가 상위 클래스를 반환값으로 가지고 있으면
						반드시 원하는 하위 클래스 형태로 형변환해서 사용해야함
						
						참고 ]
							
							어떤 반환값이나 넘겨받은 데이터의 타입이 Object인 경우
							그 데이터로 연산을 할 때는 반드시 원래 가지는 타입으로
							강제 형변환해서 사용해야함
							
---------------------------------------------------------

추상 클래스
==> 추상 함수를 0개 이상 가지고 있는 클래스
	즉, 추상 함수가 한개도 없어도 강제로 추상 클래스를 만들 수 있고
	추상 함수가 한개라도 있으면 반드시 추상 클래스로 만들어야함
	
	추상 함수란?
	==> 함수의 몸체(블럭 : {} )가 없는 함수
		즉, 기능이 없는 함수
		
		형식 ]
			
			접근지정자	abstract	반환값	함수이름(매개변수리스트);
			
		ex ]
			
			public abstract void abc(int a);
			
			
	추상 클래스 만드는 방법 ]
	
		형식 ]
			
			접근지정자	abstract	class	클래스이름 {
				변수 선언;
				일반함수(){}
				일반함수(){}
				일반함수(){}
				
				[ 추상함수(); ] ==> 와도 되고 없어도 추상 클래스로 강제로 만들 수 있음
				
			}
			
			
		이유 ]
		
			다형성 구현을 하기 위해서
			
		추상 클래스를 사용하는 방법
		==> 추상 클래스는 new 시켜서 사용할 수 없는 클래스
			왜냐하면 그 안에는 기능이 없는 함수가 존재할 수 있기 때문에
			
			1. 다른 클래스에 상속해준 후
				추상 함수의 기능을 만들어주고 ==> {} 을 만들고 그 안에 기능을 구현하고
				상속 받은 클래스를 new 시켜서 추상 클래스의 변수에 담아서 사용하면 됨
				
			2. 실무에서는 추상 클래스 안에
				속성이 static 이면서 반환값이 자기 자신인 함수를 찾아서
				그 함수를 호출해서 인스턴스를 얻어 사용
				
				ex ]
				
					Calendar 클래스 사용법
					
						Calendar cal = Calendar.getInstance();
						
						이렇게 하면 함수가 Calendar 인스턴스를 반환해줌
				
		참고 ]
			
			추상 클래스가 아님에도 불구하고
			생성자 함수가 존재하지 않는 것처럼 보이는 클래스가 있음
			이 클래스는 생성자 함수가 존재하지 않는것이 아니라
			생성자의 접근지정자를 private으로 감춰놓은것
			이런 경우 마찬가지로 new 시켜서 사용할 수 없고
			추상 클래스와 마찬가지로
			속성이 static이면서 반환값이 자기자신인 함수를 찾아 실행해서
			객체를 만들어 사용해야함
			
			만약 자신에게 그런 함수가 없는 경우는
			관련된 클래스에 그런 함수가 존재하므로 찾아서 그 함수를 호출해 사용하면됨
						
---------------------------------------------------------

인터페이스(Interface)
==> 클래스의 한 종류이기는 하지만
	형태와 의미가 지금까지 배웠던 클래스하고는 다른
	특수한 클래스의 일종
	
	1. 최상위 클래스가 Object가 아님
	==> 즉, 인터페이스는 다른 클래스를 상속 받아서 만들어진 클래스가 아님
	
	2. 인터페이스 내에는 100% 추상 함수 존재해야함
	==> 절대로 일반함수가 존재하면 안됨
		기능이 구현된 함수가 존재하면 안됨 (블럭이 있는 함수가 있으면 안됨)
	
		참고 ]
			
			인터페이스 내에서는 자동적으로
			접근지정자와 속성을 기술하지 않아도
				public abstract
			붙여지게됨
			
	3. 인터페이스는 다른 클래스에 상속해줄 수 있는데 (반드시 상속해줘야함)
	   다중 상속 가능
	   
	4. 변수는 가질 수 있음
	   이 때 이 변수는 자동적으로
	   public static final이 붙게 됨
	
	왜 인터페이스를 만들어서 사용하는가?
	==> 가끔은 JVM에 의해서 자동 호출되어야 하는 함수 필요
		따라서 함수의 존재는 필요함
		가끔은 이 함수가 해야할 일을 개발자가 정해야 되는 경우가 있음
		따라서 기능은 개발자의 몫으로 남긴 것
		
인터페이스 사용하기

	1. 인터페이스는 스스로 new 되지 못함
		추상 클래스와 마찬가지로
		인터페이스 소속 함수는 기능이 없기 때문에 new 시킬 수 없음
		
		따라서 일반 클래스에게 상속해줌
		
		상속 방법 ]
			
			class 클래스이름 [ extends 상속해줄 클래스 ] implements 인터페이스이름, 인터페이스이름,  ... {}
						
		참고 ]
		
			일반 클래스를 상속 받는 것을 "상속" 이라 표현
			인터페이스를 상속 받는 것을 "구현" 이라 표현			
						
	2. 상속 받은 클래스에서는
	   인터페이스 안에 있는 함수를 100% 오버라이드 해야함
	   그리고 필요한 기능을 개발자가 구현함
	   ==> 인터페이스 소속 함수는 접근지정자가 public
	   
	3. 상속 받아 만든 일반 클래스를 new 시켜서 사용
	==> 이 방법이 인터페이스를 사용하는 90% 정도의 사용 방법
	
		10% 정도는 속성이 static 이면서 해당 인터페이스 타입인 함수를 찾아서 사용함
		이 때 추상 클래스와의 차이점
		추상 클래스는 해당 클래스 내에 이런 함수가 존재하지만
		인터페이스의 경우는 기능을 가지는 함수가 존재하지 않기 때문에
		다른 클래스 소속의 함수를 찾아야함
		
	참고 ]
		
		인터페이스는 다중 상속 가능
		
		이 경우 구현하는 모든 인터페이스 소속의 모든 함수를 오버라이드 해야함
		
		주의 ]
			
			반드시 클래스 상속 구문이 인터페이스 구현보다 먼저 와야함
			
---------------------------------------------------------
이 부분은 잊어먹어도 됩니다.

	참고 ]
		
		인터페이스도 다른 인터페이스를 상속받아서 만들 수 있음
		
		형식 ]
			
			interface 새로운 인터페이스이름 extends 상속해 줄 인터페이스 {
			}
			
	참고 ]
	
		인터페이스 안에도 일반 함수가 오는 경우 있음
		이 경우에는 반드시 함수의 속성을 default 라고 명시해야함
		
		형식 ]
			
			default 반환값타입 함수이름(){}
			
---------------------------------------------------------

내부 클래스(Inner Class)
==> 클래스 안에 다시 클래스를 만들 수 있음

종류 ]
	
	1. Top Level Inner Class
	==>
		비록 형식은 내부 클래스이지만 독립적으로 활동하는 클래스
		
		형식 ]
		
			static class 클래스이름 {}
			
		즉, 내부에 만들면서 static이 붙으면 Top level Inner Class
		
		참고 ]
		
			클래스이름
			일반 클래스와 달리 내부 클래스의 이름은
			"바깥 클래스이름.내부 클래스이름" 의 형식을 취함
			
	***
	2. 전역 Inner Class
		==>
			일반 클래스를 내부 클래스로 만든것
			(이 클래스가 우리가 일반적으로 내부 클래스라고 부르는 것의 90% 차지)
			
		형식 ]
			
			class 클래스이름 {}
			
		특징 ]
			
			1. 바깥 클래스의 모든 멤버를 자기 것인양 사용 가능
			2. 반드시 바깥 클래스를 new 시킨 후
				안쪽 클래스를 생성할 수 있음
				
				형식 ]
					
					바깥 클래스주소.new 안쪽 클래스이름();
					
			3. 바깥 클래스는 안쪽 클래스의 멤버를 사용할 수 없고
				사용하기를 원하면 new 시켜서 사용해야함
			
		주로 바깥 클래스와 연관된 기능을 가진 클래스를 만들고 싶을 때 많이 사용하는 방법
	---------------------------------------------------------
	참고 ]
	 
	 	우리가 클래스를 제작한다는 것은
	 	소스코드파일 하나를 만드는 것과 동일함
	 	
	 	그런데 클래스의 내용이 짧으면 파일을 따로 만드는 것이 번거로울 수 있음
	 	
	 	이런 경우 주로 내부 클래스를 활용하면 편함
	
	---------------------------------------------------------		
					
	3. 지역 Inner Class
		==> 내부 클래스를 만드는 위치가
			바깥 클래스의 함수 안에서 만들어지는 것
			
			ex ]
			
				class Test {
					int a;
					class Inner {}		==> 전역 내부 클래스
					
					void abc()
						int no = 0;
						
						class Inner02 {	==> 지역 내부 클래스
						}
					}
				}
				
			특징 ]
				
				1. 전역 내부 클래스와 유사하게 바깥 클래스의 멤버를 사용 가능
				2. 이 클래스는 다른 곳에서는 new 시킬 수 없음
					오직 그 함수 안에서만 new 시켜서 사용 가능
	***   
	4. 무명 Inner Class
	==> 이름이 없는 내부 클래스
		
		프로그램을 제작하다보면 클래스의 기능 수정을 위해서
		오버라이드를 해야하는 경우 발생
		(또는 인터페이스나 추상 클래스를 사용해야 할 때)
		
		이럴 때 원칙적으로는
		상속을 받아서 다른 클래스를 만들고
		그 클래스를 객체로 만든 후 사용해야 함
		
		이 때 간단한 오버라이드의 경우라면
		그 기능 하나 때문에 전체 작업이 번거로울 수 있음
		
		결론적으로
		무명 클래스란?
		이런 경우를 위해서 만들어진 클래스로
		클래스를 new 시키는 순간 필요한 기능을 오버라이드해서 사용하는 방법
		
		사용자가 클래스이름을 만들지 않아도 되고
		그런 의미에서 무명 내부 클래스라고 부름
		
		형식 ]
			
			new 인터페이스이름(){
				추상함수 오버라이드...
			}
			
			new 추상 클래스이름(){
				추상함수 오버라이드...
			}
	   
