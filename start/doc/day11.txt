#day11

this
==> 교과서적인 의미로는
	현재 실행중인 객체의 주소를 기억하는 약속된 변수
	
	이것은 JVM이 클래스를 처리하기 위해서 JVM이 사용하는 변수
	즉, 개발자는 거의 이 변수를 사용하지 않음
	
	규칙 ]
	
		1.  모든 멤버는 사용할 때 반드시 앞에 주소가 있어야함
			멤버는 클래스 안에 만들어진 변수나 함수를 이야기함
			
			따라서 new 시킨 후 그 주소를 기억해 놓았다가
			그 주소를 이용해서 사용하는 것
			
		2.	만약 주소가 없으면 JVM이 자동적으로 this를 붙여줌
		3.	멤버 함수를 호출할 때는 무조건 주소값을 함수한테 알려주도록 약속되어있고
			함수는 this 변수를 준비한 후
			함수를 호출할 때 알려준 주소를 기억하게 됨
	
	참고 ]
	
		딱 한 번 개발자가 this를 사용해야 하는 경우가 있는데
		가끔은 지역변수와 멤버변수가 이름이 동일하게 만들어지는 경우가 있음
		이 때 그 함수는 지역변수를 우선적으로 사용하게 됨
		따라서 멤버변수(전역변수)에는 데이터가 기억되지 않을 수 있음
		
		*
		이 때
		굳이 이 변수가 멤버변수임을
		반드시 밝혀야되는 경우가 생기면
		강제로 this 라고 써주면 됨
		
------------------------------------------------------

속성
	
	static 속성
	==> static 영역에 생기는 함수나 변수에 붙여주는 속성
	
		참고 ]
			
			클래스, 함수, 변수를 만들 때 속성 지정 가능
			
			ex ]
			
				접근지정자	[속성]	class	클래스이름	{}
				접근지정자	[속성]	반환값타입	함수이름(매개변수리스트){}
				접근지정자	[속성]	데이터타입	변수이름;
				
		static 영역의 특징
			
			1. 프로그램이 실행되기 위해서 JVM이 로딩되는 순간 저절로 생기는 영역
				즉, 사용자가 특별히 만들어달라고 요구하지 않아도 자동적으로 생성
				
			2. 한 번 생긴 변수나 함수는 두번 다시 생기지 않음
			
		static 변수
		==> static 영역에 만들어지는 변수
		
			형식 ]
				
				접근지정자	static	[속성]	데이터타입	변수이름;
				
				ex ]
			
				public static final int BLACK = 1004;
			
			특징 ]
				
				1. 여러 오브젝트(객체)가 공동으로 사용하는 변수
					왜??
						오브젝트를 100개를 만들어도
						static 변수는 static 영역에 한번만 올려지기 때문
						따라서 한 오브젝트가 데이터를 바꾸면
						다른 오브젝트들도 바뀐 데이터를 사용해야함
						
						따라서 결국 static 변수는 오브젝트의 의미가 없음
						그리고 오브젝트가 없어도 사용할 수 있음
						
				2. new 시키지 않아도 사용할 수 있는 변수
					왜??
						이미 static 영역에 올려져 있기 때문에
						
					결론적으로
						사용방법
							
							클래스이름.변수이름;
							클래스이름.함수이름(데이터);
							
	*****
	static 멤버에는 this를 붙일 수 없음
	
	static 함수
	==> static 변수와 마찬가지로 static 영역에 올려지는 함수
		따라서 객체를 만들지 않아도 사용 가능한 함수
		
		사용방법 ]
			
			클래스이름.함수이름();
			
		특징 ]
		==> this 사용 불가
		
	**
	결론 ]
		
		static 함수 안에서는 메모리에 올려진 것들만 사용 가능
		일반함수 안에서는 static 멤버 그리고 일반 멤버도 사용 가능
		
------------------------------------------------------

멤버 변수의 초기화
==> 멤버 변수는 Heap 영역에 생기므로 자동 초기화
	하지만 가끔은 변수에 기본적인 값을 지정할 필요가 있음
	
	1. 명시적 초기화
	==> 변수를 선언하면서 값을 대입하는 것
		가장 먼저 실행되는 방법
		
		ex ]
			
			class Test {
				int no = 10; ==> 명시적 초기화
			}
			
	2. 초기화 블럭을 이용한 초기화
	==> 이것은 인스턴스 변수에 한해서만 가능한 방법으로
		두번째로 실행되는 방법
		
		방법 ]
			
			{
				이 안에서 데이터를 변수에 입력;
			}
			
	3. static 블럭을 이용한 초기화
		==> 위의 2번과 마찬가지로 static 변수에 한해서만 가능한 방법
			두번째로 실행되는 방법
			
			형식 ]
			
				static { // ==> static 블럭
					데이터입력
				}
				
			예 ]
			
				class Test {
					static int no;
					
					static {
						no = 100;
					}
				}
		
	4. 생성자를 이용한 초기화
	==> 가장 마지막에 실행되는 방법
	
		ex ]
		
			class Test {
				int no;
				
				public Test(){
					no = 100; // 생성자를 이용한 초기화
				}
			}
			
------------------------------------------------------

객체지향 언어의 특징
	1. 상속
	2. 다형성
	3. 은닉화 / 캡슐화

------------------------------------------------------

상속 ]
==> 이미 만들어진 클래스의 기능을 그대로 부여받아서
	(변수와 함수의 기능을 그대로 복사해 와서)
	새로운 클래스를 만드는 방법
	
	소프트웨어 개발 속도를 빠르게 하기 위한 방법의 한가지
	
	즉, 상속은 객체지향에서 매우 중요한 역할을 하는 것으로
	객체지향언어는 부품 단위(클래스)로 프로그램을 만든 후
	그 부품을 조립해서 원하는 결과를 얻어내는 것
	
	어딘가에서 부품(클래스)을 구했는데
	그 기능이 사용자 마음에 꼭 맞지는 않을 수도 있음
	이 때 처음부터 다시 만들어야 하나? 라는 문제에서
	이 문제를 해결하기 위해 만들어진 방법
	
	상속은 자신이 만들고자 하는 부품과 가장 유사한 부품을 가지고 와서
	일단 그 기능을 다 복사한 후
	
		1. 없는 기능은 더하고
		2. 수정할 기능은 수정하고
		
	상속하는 형식 ]
		
		접근지정자	[속성]	class	클래스이름	extends	복사해 올 클래스이름 {
		
		}

	***
	참고 ]
		
		자바는 오직 단일 상속만 가능
		즉, 상속은 오직 한개의 클래스에서만 받을 수 있음
		
		ex ]
		
			class NewClass extends Old1, Old2 {
			
			} ==> X
			
			class NewClass extends Old {
			
			} ==> O
			
	용어 ]
	
		상속을 해준 클래스 ==> 상위 클래스, Super Class		(부모)
		상속을 받은 클래스 ==> 하위 클래스, Sub Class		(자식)
		
		is a	==> 상속 관계에 있는 클래스를 부르는 용어
					
					class Father {}
					class Son extends Father {}
					
					==> Son is a Father 성립
					
					Father f = new Son();
					
					Son s = (Son) new Father();
		
		has a	==> 어떤 클래스 안에 다른 클래스를 멤버로 가지고 있는 상태
				
					class Father {}
					class Son {
						Father f = new Father();
					}
					
					==> Son has a Father; 성립
					
	상속 관계에 있는 경우 생성자의 역할
	
		하위 클래스가 생성되는 순간
		상위 클래스의 객체가 자동 생성
		==> 생성되는 순간 생성자 함수 호출
			따라서 하위 클래스를 생성하면
			상위 클래스의 기본 생성자 함수도 실행됨
			
		상위 클래스의 생성자 함수 자동 호출
		자동 호출되는 경우는 무조건 기본 생성자만 이용하게 됨
		
		***
		
		참고 ]
		
			super()
				==> 상위 클래스의 특별한 생성자를 강제로 호출하는 기능을 가진 명령
					현재 클래스의 생성자 함수에서 상위 클래스의 생성자를 호출하는 유일한 방법
					
			특징 ]
			
				1. 반드시 생성자 함수 안에서만 사용해야 하고
				2. 반드시 첫 줄 첫 문장으로만 올 수 있음
				
			예 ]
				
				class Father {
					int no;
					public Father(){
					}
					public Father(int no){
						this.no = no;
					}
					
				}
			
				class Son extends Father {
					char ch;
					
					public Son(){}
					public Son(int no){
						super(no);
						this.ch = ch;
					}
				}
				
------------------------------------------------------

*****
함수의 오버라이딩(Overriding : 함수의 재정의)
==> 상속관계에 있는 하위 클래스에서
	상위 클래스가 가지고 있는 함수의 기능을 수정하는 행위
	
	방법 ]
	
		0. 상위 클래스에 함수가 존재해야함
		1. 상위 클래스가 가진 함수의 원형(Prototype)과 동일한 원형으로 만들어야함
			
			참고 ]
				
				함수의 원형(Prototype)
					반환값 + 함수이름 + 매개변수리스트
					
		2. 접근지정자는 같거나 넓은 방향으로 기술함
		3. 예외처리는 같거나 좁은 방향으로... (이후 다시 설명)
		
	오버라이딩을 하면
	내부적으로 super의 함수가 숨겨지고 재정의한 함수가 사용됨
	
		public void abc(){}
		
		==> public void abc(){
				System.out.println("만세");
		}
		
		이 경우
		상위 클래스의 abc함수 호출하는 방법
			
			super.abc();
			
			abc();
			
	super
	==> this가 현재 실행중인 객체 자기 자신을 기억하는 예약된 변수이듯이
		super 역시 예약된 변수 중 하나
		자신의 상위 클래스의 객체의 주소를 기억하는 변수
		
		사용목적 ]
			
			반드시 소속을 밝혀야하는 경우가 생길 때 사용함
		
------------------------------------------------------

Object 클래스
==> 자바로 만들어진 모든 클래스들의 최상위 클래스의 역할을 하는 클래스
	따라서 자바로 만들어진 모든 클래스는 Object가 제공하는
	모든 기능(멤버 : 변수, 함수)을 자동적으로 사용할 수 있게됨
	public class Abc {} ==> Object + alpha
	
	Object o = new Abc(); ==> 다형성
	
------------------------------------------------------

참고 ]

	최상위 클래스를 만들어 놓은 이유
	계층추적을 원활하게 하기 위한 조치
	즉, 각각의 클래스의 족보를 정확하게 따질 수 있도록 하기 위해서
	
참고 ]
	
	자바로 만든 모든 클래스는 반드시 상위 클래스를 가지고 있음
	우리가 지금까지 만든 클래스들도 상위 클래스를 가지고 있음
	만약 강제로 상위 클래스를 지정하지 않으면("extends 클래스이름" 이라고 붙이지 않으면)
	암묵적으로 Object 라는 클래스를 상속 받아서 만들어짐
	
	**
	instanceof
	==> 특정 클래스를 new 시키면 주소가 만들어지는데
		이 주소가 어떤 클래스 소속의 주소인지를 알아내는 연산자
		연산의 결과는 true 또는 false로 만들어짐
		
		형식 ]
		
			주소	instanceof	클래스이름
			
		의미 ]
		
			주소가 가리키는 내용이
			지정한 클래스 소속인지를 물어봄
			(주소가 클래스이름의 인스턴스니?)
			
		참고 ]
		
			소속이라는 개념은 is a 관계를 따지는 것
			상속 관계를 따지는 개념이 소속이라는 것
			
------------------------------------------------------

package와 import

	package란?
	==> 자바 프로그램(소스코드)이 들어있는 폴더를
		자바에서 부르는 용어
		
		자바는 오픈소스
		모든 사람이 자신이 만든 프로그램을 제공할 수 있고
		그것을 모든 사람이 이용할 수 있음
		그러다보니 문제점이 발생했는데
		클래스이름이 충돌날 수 있음
		이런 문제를 해결하기 위해서 만들어 놓은 한가지 방법이 바로 패키지
		
		즉, 소스를 만드는 사람이 그 프로그램이 포함되는 폴더이름까지 정해서
		프로그램을 만들도록 하는 것
		
		결론적으로
		자바로 프로그램을 만들때는 반드시 이 프로그램이
		어떤 폴더에 저장되는지를 알려주도록 해놓았음
		
		명령 ]
		
			package	폴더이름;
			
		참고 ]
			
			패키지 이름을 만드는 권장사항
			자신이 사용하는 도메인을 거꾸로 쓴 후 그 다음에 다시 폴더이름을 붙여서 만들어줌
			이 때 경로의 구분자는 / 를 쓰는것이 아니고
			자바에서는 . 으로 구분해서 처리
			
			ex ]
			
				githrd.com
				==> 
				com.githrd.t0310				
		
	import란?
	==> 자신이 사용할 클래스가 어느 폴더(패키지)에 있는
		클래스를 사용할 것인지를 밝혀주기 위한 명령
		
		ex ]
		
			내가
				Sample.Test.class
			희진
				heejin.Test.class
				
		==> 희진의 프로그램을 사용하고 싶음
		import heejin.Test;
		
		==> 내가 만든 Test를 사용하고 싶음
		import Sample.Test;
		
		형식 1 ]
		
			import 패키지경로.클래스이름;
			==> 지정한 폴더의 지정한 클래스를 사용할 예정임을 밝히는 것
			
		형식 2 ]
			
			import 패키지경로.*;
			==> 지정한 경로에 있는 모든 클래스 중 일부를 사용할 예정임을 밝혀주는 것
		
			주의 ]
				
				t1	------	s1 --- .....
						|
						|-- s2 --- Test1.java
						|		|- Test2.java
						|		|- Test3.java
						|-- Test01.java
						|-- Test02.java
						|
				이 경우
					import t1.*;
					==> Test01, Test02만 사용할 준비를 하게됨
					
					만약 Test1을 사용하려면
					import t1.s2.*; 라고 별도로 import 해야함
					
				따라서 결론적으로 * 기호를 사용한 import 명령은
				하위의 패키지 내의 클래스까지 사용할 준비를 하는 것이 아니고
				직속 클래스만 사용할 준비하는 것
				
		참고 ]
		
			2번보다는 1번을 우선적으로 적용시킴
			
				ex ]
				
					sample.Test.java
					test.Test.java
					
					import test.Test;
					import sample.*;
					
					==> 사용하는 Test 클래스는 test 패키지의 Test 클래스를 사용하게 됨
					
		참고 ]
		
			import를 하지 않아도
			명시적으로 사용할 수 있는 패키지가 있는데
			java.lang 패키지
			왜? JVM이 기본적으로 찾아보는 패키지이기 때문
			
------------------------------------------------------

	static import
	==> static 멤버는 원칙적으로
				클래스이름.멤버이름
		로 사용함
		
		Math.PI
		Math.random()
		
		이 때 static 멤버 앞에 사용하는 클래스이름조차도 생략 가능
		==> 이처럼 static 멤버를 사용할 때
			클래스이름을 생략할 수 있도록 하는 방법이
			static import
			
		형식 ]
			
			import static 패키지경로.클래스이름.*;
			
			random() ==> Math 클래스의 random() 함수를 호출하게 됨
			
------------------------------------------------------

final 속성

	1. final 변수
		==> 이 변수는 값을 수정할 수 없는 변수
			즉, 현재 값을 유지해야만 하는 변수
			<== 선언과 동시에 초기화를 하는 것이 일반적
			
	2. final 함수
		==> 이 함수는 오버라이드(함수의 재정의)가 불가능한 함수
			따라서 이 함수는 매우 중요한 함수이므로
			함부로 기능을 바꾸지 말고 현재 기능 그대로 사용 
		
	3. final 클래스
		==> 이 클래스는 더 이상 상속이 불가능한 클래스임을 밝히는 속성
			기능을 추가 혹은 변경하지 말고
			현재 기능 그대로만 이용하라는 의미의 클래스
					
------------------------------------------------------	
					
	상위클래스의 타입 변수로 하위 클래스의 인스턴스를 기억하는 경우
	변수는 레퍼런스쪽을 따르고
	함수는 인스턴스쪽을 따름
	단, 레퍼런스 쪽에 실행하려는 함수가 존재해야함








	
	
	
	
	
	
	
	
	
	
	
	